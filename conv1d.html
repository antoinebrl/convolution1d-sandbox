<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v4.min.js"></script>
</head>
<body>
  <input type="number" id="dilatation" value=1>
  <input type="number" id="stride" value=1>
  <br>
  <input type="button" id="new" value="New">
  <input type="button" id="delete" value="delete">
  <br>
  <input type="button" id="prevstep" value="Previous">
  <input type="button" id="nextstep" value="Next">

  <script>
  const width = 500;
  const height = 575;

  const svg = d3.select("body")
      .append("svg")
      .attr("width", width)
      .attr("height", height);

  const border = svg.append("rect")
      .attr("fill", "lightblue")
      .attr("x", 0)
      .attr("y", 0)
      .attr("height", height)
      .attr("width", width);

  const colors = ['#ffffee', '#ffeebb', '#c2e699', '#78c679', '#31a354', '#006837'];
  const kernel_line_y = 75;
  const func_line_y = 200;
  const conv_line_y = 325;
  const out_line_y = 475;
  const magnitude_max = 50;
  const pts_spacing = 25;
  const kernel_max_support = 7;
  const radius = 8;
  let dilatation = 1;
  let stride = 1;
  let pad = 0;
  let step = 0;

  const kernel_fn = d3.range(5).map(i => ({
      y: magnitude_max*(Math.random() - 0.5) * 2,
  }));
  const func_fn = d3.range(19).map(i => ({
      y: magnitude_max*(Math.random() - 0.5) * 2,
  }));
  let out_fn = [];

  const kernel = svg.append("g").attr("id", "kernel");
  const conv = svg.append("g").attr("id", "conv");
  const ops = conv.append("g").attr("id", "ops");
  const func = svg.append("g").attr("id", "func");
  const out = svg.append("g").attr("id", "out");

  dragY = function() {

      function dragstarted(d) {
          d3.select(this).attr("stroke", "black");
      }

      function dragged(d) {
          y = d3.event.y;
          y = Math.max(-magnitude_max, y);
          y = Math.min(+magnitude_max, y);
          d.y = y;

          updateKernel();
          updateFunc();
          drawConv();
          computeConv();
          updateOut();

      }

      function dragended(d) {
          d3.select(this).attr("stroke", null);
      }

      return d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended);
  }

  function updateXaxis(root, data, dilatation) {
    if (root.select("#hline").empty()) {
        root.append("line")
            .attr("id", "hline")
            .attr("y1", 0)
            .attr("y2", 0)
            .attr("stroke", "gray")
            .attr("stroke-width", 2);
    }
    root.select("#hline")
      .attr("x1", 0)
      .attr("x2", data.length * pts_spacing * dilatation);
  }

  function updateCenteredLayout(root, data, line_y, dilatation) {
    root.attr("transform", "translate(" +
         (width - data.length * pts_spacing * dilatation) / 2 +
         "," +
         line_y + ")"
       );
  }


  function updateConvLayout() {
    conv.attr("transform", "translate(" +
         ((width - func_fn.length * pts_spacing) / 2 + pts_spacing * step * stride - pts_spacing * (dilatation - 1) / 2 ) +
         "," +
         conv_line_y + ")"
       );
  }

  function updateOutputLayout() {
    out.attr("transform", "translate(" +
        ((width - func_fn.length * pts_spacing) / 2 + pts_spacing * ((kernel_fn.length - 1) * dilatation + 1) / 2 - pts_spacing * stride / 2) +
        "," +
        out_line_y + ")"
      );
  }

  function draw(root, data, dilatation) {
    // data binding
    const vlines = root.selectAll("#vline").data(data);
    // remove elements no longer in data
    vlines.exit().remove();
    // Create new entry for new elements in data
    const new_lines = vlines
        .enter()
        .append("line")
        .attr("id", "vline")
        .attr("stroke", "gray")
        .attr("stroke-width", 2);
    // Operates on both new and old elements
    vlines
        .merge(new_lines)
        .attr("x1", function(d, i) { return pts_spacing * (i + 0.5) * dilatation; })
        .attr("y1", 0)
        .attr("x2", function(d, i) { return pts_spacing * (i + 0.5) * dilatation; })
        .attr("y2", function(d, i) { return d.y; });

    // data binding
    const cercles = root.selectAll("circle").data(data);
    // remove elements no longer in data
    cercles.exit().remove();
    // Create new entry for new elements in data
    const new_circles = cercles
        .enter()
        .append("circle")
        .attr("fill", function(d, i) { return colors[i]; })
        .call(dragY());
    // Operates on both new and old elements
    cercles
        .merge(new_circles)
        .attr("cx", function(d, i) { return pts_spacing * (i + 0.5) * dilatation; })
        .attr("cy", function(d, i) { return d.y; })
        .attr("r", radius)
  }


  function drawConvOps(root, data, dilatation) {
      // data binding
      const mult_lines = root.selectAll("#multline").data(data);
      // remove elements no longer in data
      mult_lines.exit().remove();
      // Create new entry for new elements in data
      const new_mutl_lines = mult_lines
          .enter()
          .append("line")
          .attr("id", "multline")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1);
      // Operates on both new and old elements
      mult_lines
          .merge(new_mutl_lines)
          .attr("x1", function(d, i) { return pts_spacing * (i + 0.5) * dilatation; })
          .attr("y1", function(d, i) { return d.y; })
          .attr("x2", function(d, i) { return pts_spacing * (i + 0.5) * dilatation; })
          .attr("y2", -125 );

      // data binding
      const add_lines = root.selectAll("#addline").data(data);
      // remove elements no longer in data
      add_lines.exit().remove();
      // Create new entry for new elements in data
      const new_lines = add_lines
          .enter()
          .append("path")
          .attr("id", "addline")
          .attr("stroke", "darkorange")
          .attr("stroke-width", 1)
          .attr("fill", "none");
      // Operates on both new and old elements
      add_lines
          .merge(new_lines)
          .attr("d", function(d, i) {
            const x_pts = pts_spacing * (i + 0.5) * dilatation;
            const x_middle = pts_spacing * data.length / 2 * dilatation;
            const points = [
              [x_pts, Math.max(d.y, - radius / 2) + 10],
              [x_pts, magnitude_max + 15],
              [x_pts, magnitude_max + 20],
              [x_middle, magnitude_max + 20],
              [x_middle, magnitude_max + 25],
              [x_middle, magnitude_max + 150 - magnitude_max],
            ];

            const line = d3
                     .line()
                     .x(d => d[0])
                     .y(d => d[1])
                     .curve(d3.curveBundle.beta(1));
            return line(points);
           });
    }

  function updateKernel() {
    updateCenteredLayout(kernel, kernel_fn, kernel_line_y, dilatation);
    updateXaxis(kernel, kernel_fn, dilatation)
    draw(kernel, kernel_fn, dilatation);
  }

  function updateFunc() {
    updateCenteredLayout(func, func_fn, func_line_y, 1);
    updateXaxis(func, func_fn, 1)
    draw(func, func_fn, 1);
  }

  function updateConv() {
    updateXaxis(conv, kernel_fn, dilatation);
    drawConv();
  }

  function updateOut() {
    // updateCenteredLayout(out, out_fn, out_line_y, 1);
    updateXaxis(out, out_fn, stride)
    draw(out, out_fn, stride);
  }

  function drawKernel() {
    draw(kernel, kernel_fn, dilatation);
  }

  function drawFunc() {
    draw(func, func_fn, 1);
  }

  function drawConv() {
    draw(conv, kernel_fn, dilatation);
    drawConvOps(ops, kernel_fn, dilatation);
  }

  function computeConv() {
    out_fn = [];
    for (let s = 0; s <= step; s++) {
      let c = 0;
      for (let i = 0; i < kernel_fn.length; i++) {
        c += kernel_fn[i].y * func_fn[s * stride + i * dilatation].y
      }
      out_fn.push({x: 0, y: - c / kernel_fn.length / magnitude_max});
    }
  }

  computeConv();
  updateKernel();
  updateFunc();
  updateCenteredLayout(conv, func_fn, conv_line_y, dilatation);
  updateConvLayout();
  updateConv();
  updateOutputLayout();
  updateOut();


  d3.select("#stride")
    .on("input",   function() {
        stride = this.value;
        updateKernel();
        if (step * stride + kernel_fn.length > func_fn.length ) {
          step -= 1;
          updateConvLayout();
        }
        updateConvLayout();
        updateConv();
        updateConvLayout();
        computeConv();
        updateOutputLayout();
        updateOut();
    })

  d3.select("#dilatation")
    .on("input",   function() {
        dilatation = this.value;
        while (step + (kernel_fn.length - 1) * dilatation + 1 > func_fn.length ) {
          step -= 1;
        }
        updateKernel();
        updateConvLayout();
        updateConv();
        updateConvLayout();
        computeConv();
        updateOutputLayout();
        updateOut();
    })


  d3.select("#prevstep")
    .on("click", function(){
      if (step > -pad  ) {
        step -= 1;
        updateConvLayout();
        computeConv();
        updateOut();
      }
      console.log("step:" + step)
      console.log("stride:" + stride)
      console.log("dilatation:" + dilatation)
    })
  d3.select("#nextstep")
    .on("click", function(){
      if ((step + 1)* stride + (kernel_fn.length - 1) * dilatation + 1  <= func_fn.length ) {
        step += 1;
        updateConvLayout();
        computeConv();
        updateOut();
      }
      console.log("step:" + step)
      console.log("stride:" + stride)
      console.log("dilatation:" + dilatation)
    })

  d3.select("#new")
    .on("click", function(){
      if (kernel_fn.length < kernel_max_support) {
        kernel_fn.push({x: kernel_fn.length, y:0})
        updateKernel();
        while (step * stride + kernel_fn.length > func_fn.length ) {
          step -= 1;
        }
        updateConvLayout();
        updateConv();
        updateOutputLayout();
        computeConv();
        updateOut();
      }
    })
  d3.select("#delete")
    .on("click", function(){
      if (kernel_fn.length > 1) {
        kernel_fn.pop({x: kernel_fn.length, y:0})
        updateKernel();
        updateConv();
        updateOutputLayout();
        computeConv();
        updateOut();
      }
    })

  </script>
</body>
</html>
