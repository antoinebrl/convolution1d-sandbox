<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/x-mathjax-config">
  MathJax = {
    loader: {load: ['[tex]/color']},
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)'], ['\\[', '\\]']],
      packages: {'[+]': ['color']}
    },
    svg: {
      fontCache: 'global'
    }
  };

  </script>
  <script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/input/tex/extensions/colorV2.js" charset="UTF-8"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/input/tex/extensions/color.js" charset="UTF-8"></script>
</head>
<body>
  <p>dilation:
    <input type="number" id="dilatation" value=1 min="1" max="3">
  </p>
  <p>stride:
    <input type="number" id="stride" value=1 min="1" max="3">
  </p>
  <p>padding:
    <input type="number" id="padding" value=0 min="0" max="4">
  </p>
  <p>
    <input type="button" id="new" value="New">
    <input type="button" id="delete" value="delete">
  </p>
  <p>
    <input type="button" id="reset" value="Reset">
    <input type="button" id="prevstep" value="Previous">
    <input type="button" id="play" value="Play">
    <input type="button" id="nextstep" value="Next">
  </p>

  <div id="math"></div>

  <script>
const width = 575;
const height = 575;

const kernel_color = "#C72E38"
const func_color = "#1d3557"
const mult_color = "#d94a64"
const add_color = "#679436"
const out_color = "#8e576d"
const duration = 350


const kernel_line_y = 75;
const func_line_y = 200;
const conv_line_y = 325;
const out_line_y = 475;

const magnitude_max = 50;
const pts_spacing = 25;
const kernel_max_support = 7;
const radius = 8;

let dilatation = 1;
let stride = 1;
let padding = 0;
let step = 0;
let animate = false;

const svg = d3.select("body")
.append("svg")
.attr("width", width)
.attr("height", height);

const border = svg.append("rect")
.attr("fill", "#f4f1de")
.attr("x", 0)
.attr("y", 0)
.attr("height", height)
.attr("width", width);

const kernel_fn = d3.range(5).map(i => ({ y: magnitude_max * (Math.random() * 2 - 1)}));
const func_fn = d3.range(15).map(i => ({ y: magnitude_max * (Math.random() * 2 - 1)}));
let func_padded_fn = [];
let out_fn = [];

const kernel = svg.append("g").attr("id", "kernel");
const conv = svg.append("g").attr("id", "conv");
const ops = conv.append("g").attr("id", "ops");
const pad_left = svg.append("g").attr("id", "pad_left");
const pad_right = svg.append("g").attr("id", "pad_right");
const func = svg.append("g").attr("id", "func");
const out = svg.append("g").attr("id", "out");


function printLabel(label, line_y) {
  svg.append("text")
      .attr("stroke-width", "2")
      .attr("fill", "#5e6472")
      .attr("transform", "rotate(-90) translate(-" + line_y + ", 20)")
      .attr("text-anchor", "middle")
      .attr("font-family", "monospace")
      .attr("dominant-baseline", "middle")
      .text(label);
}
printLabel("kernel", kernel_line_y);
printLabel("signal", func_line_y);
printLabel("convolution", conv_line_y);
printLabel("result", out_line_y);




function padFunc(fn, pad) {
  let padded = [];
  for (let i = 0; i < pad; i++) {
    padded.push({y: 0});
  }
  padded = padded.concat(fn);
  for (let i = 0; i < pad; i++) {
    padded.push({y: 0});
  }
  return padded;
}

function computeConv(f, g) {
    out_fn = [];
    for (let s = 0; s <= step; s++) {
        let c = 0;
        for (let i = 0; i < g.length; i++) {
            c += g[i].y * f[s * stride + i * dilatation].y
        }
        out_fn.push({
            x: 0,
            y: -c / magnitude_max
        });
    }
    return out_fn;
}

function updateEquation() {
    const equation = document.getElementById("math");

    latex_equation = "\\textcolor{" + out_color + "}{(f * g)}("+ step + ") "
    latex_equation += "= "
    latex_equation += "\\textcolor{" + add_color + "}{\\sum_{k}^{K}}"
    latex_equation += "\\textcolor{" + func_color + "}{f_{i+j}}"
    latex_equation += "\\textcolor{" + mult_color + "}{\\mathbf{\\times}} "
    latex_equation += "\\textcolor{" + kernel_color + "}{w_j}"

    equation.innerHTML = "<p>" + "\\[" + latex_equation + "\\]" + "</p>";
    try {
      MathJax.typeset(["#math"]);
    } catch (error) {
    }
}

dragY = d3.drag()
    .on("start", function(d) {
        d3.select(this).attr("stroke", "black");
    })
    .on("drag", function(d) {
        y = d3.event.y;
        y = Math.max(-magnitude_max, y);
        y = Math.min(+magnitude_max, y);
        d.y = y;

        update();
    })
    .on("end", function(d) {
        d3.select(this).attr("stroke", null);
    })

//// Draw X axis line
function updateXaxis(root, n, dilatation) {
    if (root.select("#hline").empty()) {
        root.append("line")
            .attr("id", "hline")
            .attr("y1", 0)
            .attr("y2", 0)
            .attr("stroke", "gray")
            .attr("stroke-width", 2);
    }
    root.select("#hline")
        .transition()
        .duration(animate * duration)
        .attr("x1", 0)
        .attr("x2", n * pts_spacing * dilatation);
}

//// Update group top right corner positions
function updateCenteredLayout(root, n, line_y, dilatation) {
    const x = (width - n * pts_spacing * dilatation) / 2;
    root.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + x + "," + line_y + ")");
}

function updatePadLeft() {
    const right = (width - func_fn.length * pts_spacing) / 2;
    const left = right - padding * pts_spacing;
    pad_left.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + left + "," + func_line_y + ")");
}

function updatePadRight() {
    const left = (width + func_fn.length * pts_spacing) / 2;
    pad_right.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + left + "," + func_line_y + ")");
}

function updateConvLayout() {
    let x = (width - func_padded_fn.length * pts_spacing) / 2
    x += pts_spacing * step * stride
    x -= pts_spacing * (dilatation - 1) / 2;
    conv.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + x + "," + conv_line_y + ")");
}

function updateOutputLayout() {
    let x = (width - func_padded_fn.length * pts_spacing) / 2
    x += pts_spacing * ((kernel_fn.length - 1) * dilatation + 1) / 2
    x -= pts_spacing * stride / 2;
    out.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + x + "," + out_line_y + ")");
}

//// Drawing primitives
function drawPadding(root, n) {
    // data binding
    const cercles = root.selectAll("circle").data(d3.range(n));
    // remove elements no longer in data
    cercles.exit().transition().duration(animate * duration / 2).attr("r", 0).remove();
    // Create new entry for new elements in data
    const new_circles = cercles
        .enter()
        .append("circle")
        .attr("fill", "lightgray")
        .attr("r", 0)
        .transition()
        .duration(animate * duration * 2)
        .attr("r", radius)
    // Operates on both new and old elements
    cercles
        .merge(new_circles)
        .attr("cx", function(i) {
            return pts_spacing * (i + 0.5);
        })
        .attr("cy", 0);

    new_circles
;
}

function drawFunction(root, data, dilatation, color) {
    // data binding
    const vlines = root.selectAll("#vline").data(data);
    // remove elements no longer in data
    vlines.exit().transition().duration(animate * duration / 2).attr("stroke-width", 0).remove();
    // Create new entry for new elements in data
    const new_lines = vlines
        .enter()
        .append("line")
        .attr("id", "vline")
        .attr("stroke", "gray")
        .attr("stroke-width", 2)
        .attr("y1", 0)
        .attr("x1", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("x2", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        });
    // Operates on both new and old elements
    vlines
        .merge(new_lines)
        .attr("y2", function(d, i) {
            return d.y;
        })
        .transition()
        .duration(animate * duration)
        .attr("x1", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("x2", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        });


    // data binding
    const cercles = root.selectAll("circle").data(data);
    // remove elements no longer in data
    cercles.exit().transition().duration(animate * duration / 2).attr("r", 0).remove();
    // Create new entry for new elements in data
    const new_circles = cercles
        .enter()
        .append("circle")
        .attr("fill", color)
        .attr("cx", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("r", 0)
        .call(dragY)
        .on("dblclick", function(d) {
            d.y = d.y ? 0 : - magnitude_max;
            update()
        });
    // Operates on both new and old elements
    cercles
        .merge(new_circles)
        .attr("cy", function(d, i) {
            return d.y;
        })
        .transition()
        .duration(animate * duration)
        .attr("cx", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("r", radius);
}

function drawConvOps(root, data, dilatation) {
    // data binding
    const mult_lines = root.selectAll("#multline").data(data);
    // remove elements no longer in data
    mult_lines.exit().transition().duration(animate * duration / 2).attr("stroke-width", 0).remove();
    // Create new entry for new elements in data
    const new_mutl_lines = mult_lines
        .enter()
        .append("line")
        .attr("id", "multline")
        .attr("stroke", mult_color)
        .attr("stroke-width", 0)
        .attr("y1", 0)
        .attr("y2", 0)
        .attr("x1", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("x2", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .transition("fade in")
        .duration(animate * duration / 2)
        .attr("stroke-width", 1.25)
        .attr("y2", -125);
    // Operates on both new and old elements
    mult_lines
        .transition()
        .duration(animate * duration)
        .attr("x1", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("x2", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })

    // data binding
    const add_lines = root.selectAll("#addline").data(data);
    // remove elements no longer in data
    add_lines.exit().transition().duration(animate * duration / 2).attr("stroke-width", 0).remove();
    // Create new entry for new elements in data
    const new_add_lines = add_lines
        .enter()
        .append("path")
        .attr("id", "addline")
        .attr("stroke", add_color)
        .attr("fill", "none");

    // Operates on both new and old elements
    add_lines
        .merge(new_add_lines)
        .transition()
        .duration(animate* duration)
        .attr("d", function(d, i) {
            const x_pts = pts_spacing * (i + 0.5) * dilatation;
            const x_middle = pts_spacing * data.length / 2 * dilatation;
            const points = [
                [x_pts, Math.max(d.y, -radius / 2) + 10],
                [x_pts, magnitude_max + 10],
                [x_pts, magnitude_max + 20],
                [x_middle, magnitude_max + 20],
                [x_middle, magnitude_max + 25],
                [x_middle, magnitude_max + 150 - magnitude_max],
            ];

            const line = d3
                .line()
                .x(d => d[0])
                .y(d => d[1])
                .curve(d3.curveBundle.beta(1));
            return line(points);
        });

    new_add_lines
        .attr("stroke-width", 0)
        .transition()
        .duration(animate * duration)
        .attr("stroke-width", 1.25);
}


function update() {
    func_padded_fn = padFunc(func_fn, padding);
    updateEquation();

    // kernel
    updateCenteredLayout(kernel, kernel_fn.length, kernel_line_y, dilatation);
    updateXaxis(kernel, kernel_fn.length, dilatation);
    drawFunction(kernel, kernel_fn, dilatation, kernel_color);

    // function
    updatePadLeft();
    updateXaxis(pad_left, padding, 1);
    drawPadding(pad_left, padding);

    updateCenteredLayout(func, func_fn.length, func_line_y, 1);
    updateXaxis(func, func_fn.length, 1);
    drawFunction(func, func_fn, 1, func_color);

    updatePadRight();
    updateXaxis(pad_right, padding, 1);
    drawPadding(pad_right, padding);

    // conv-ops
    updateConvLayout();
    // reverse kernel in a non destructive way by making a copy
    const reversed_kernel_fn = [...kernel_fn].reverse();
    updateXaxis(conv, kernel_fn.length, dilatation);
    drawFunction(conv, reversed_kernel_fn, dilatation, kernel_color);
    drawConvOps(ops, reversed_kernel_fn, dilatation);

    // result
    out_fn = computeConv(func_padded_fn, reversed_kernel_fn);
    updateOutputLayout();
    updateXaxis(out, out_fn.length, stride);
    drawFunction(out, out_fn, stride, out_color);
}
update();
animate = true;


function getConvRightPosition(step) {
    return step * stride + (kernel_fn.length - 1) * dilatation + 1;
}

//// User input
d3.select("#dilatation")
    .on("input", function() {
        dilatation = Math.min(Math.max(this.min, this.value), this.max);
        this.value = dilatation;
        while (getConvRightPosition(step) > func_padded_fn.length) {
            step -= 1;
        }
        update();
    })

d3.select("#stride")
    .on("input", function() {
        stride = Math.min(Math.max(this.min, this.value), this.max);
        this.value = stride;
        while (getConvRightPosition(step) > func_padded_fn.length) {
            step -= 1;
        }
        update();
    });

d3.select("#padding")
    .on("input", function() {
        padding = Math.min(Math.max(this.min, this.value), this.max);
        this.value = padding;
        while (getConvRightPosition(step) > func_fn.length + 2 *padding) {
            step -= 1;
        }
        update();
    });


d3.select("#prevstep")
    .on("click", function() {
        if (step > 0) {
            step -= 1;
            update();
        }
    });
d3.select("#nextstep")
    .on("click", function() {
        if (getConvRightPosition(step) + stride <= func_padded_fn.length) {
            step += 1;
            update();
        }
    });

d3.select("#new")
    .on("click", function() {
        if (kernel_fn.length < kernel_max_support) {
            kernel_fn.push({ y: 0 });
            while (getConvRightPosition(step) > func_padded_fn.length) {
                step -= 1;
            }
            update();
        }
    });
d3.select("#delete")
    .on("click", function() {
        if (kernel_fn.length > 1) {
            kernel_fn.pop({ y: 0 });
            update();
        }
    });
d3.select("#play")
    .on("click", function() {
        d3.selectAll("*").interrupt();
        svg.transition().on("end", function repeat(d){
            if (getConvRightPosition(step) + stride <= func_padded_fn.length) {
                step += 1;
                update();
                d3.active(this).transition().delay(1000).on("start", repeat);
            }
        })
    });
d3.select("#reset")
    .on("click", function() {
        d3.selectAll("*").interrupt();
        step = 0;
        update();
    });

  </script>
</body>
</html>
