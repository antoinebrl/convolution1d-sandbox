<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <p>dilation:
    <input type="number" id="dilatation" value=1 min="1" max="3">
  </p>
  <p>stride:
    <input type="number" id="stride" value=1 min="1" max="3">
  </p>
  <p>padding:
    <input type="number" id="padding" value=0 min="0" max="4">
  </p>
  <p>
    <input type="button" id="new" value="New">
    <input type="button" id="delete" value="delete">
  </p>
  <p>
    <input type="button" id="reset" value="Reset">
    <input type="button" id="prevstep" value="Previous">
    <input type="button" id="play" value="Play">
    <input type="button" id="nextstep" value="Next">
  </p>
  <p>
    \[(f * g)(i) = \sum_{k}^{} f_{i+j} \times w_j\]
  </p>
  <script>
const width = 575;
const height = 575;

const svg = d3.select("body")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

const border = svg.append("rect")
    .attr("fill", "lightblue")
    .attr("x", 0)
    .attr("y", 0)
    .attr("height", height)
    .attr("width", width);


const duration = 350

const kernel_line_y = 75;
const func_line_y = 200;
const conv_line_y = 325;
const out_line_y = 475;

const magnitude_max = 50;
const pts_spacing = 25;
const kernel_max_support = 7;
const radius = 8;

let dilatation = 1;
let stride = 1;
let padding = 0;
let step = 0;
let animate = false;

const kernel_fn = d3.range(5).map(i => ({ y: magnitude_max * (Math.random() * 2 - 1)}));
const func_fn = d3.range(15).map(i => ({ y: magnitude_max * (Math.random() * 2 - 1)}));
let func_padded_fn = [];
let out_fn = [];

function padFunc(fn, pad) {
    let padded = [];
    for (let i = 0; i < pad; i++) {
      padded.push({y: 0});
    }
    padded = padded.concat(fn);
    for (let i = 0; i < pad; i++) {
      padded.push({y: 0});
    }
    return padded;
}

const kernel = svg.append("g").attr("id", "kernel");
const conv = svg.append("g").attr("id", "conv");
const ops = conv.append("g").attr("id", "ops");
const pad_left = svg.append("g").attr("id", "pad_left");
const pad_right = svg.append("g").attr("id", "pad_right");
const func = svg.append("g").attr("id", "func");
const out = svg.append("g").attr("id", "out");

function computeConv() {
    out_fn = [];
    for (let s = 0; s <= step; s++) {
        let c = 0;
        for (let i = 0; i < kernel_fn.length; i++) {
            c += kernel_fn[i].y * func_padded_fn[s * stride + i * dilatation].y
        }
        out_fn.push({
            x: 0,
            y: -c / kernel_fn.length / magnitude_max
        });
    }
}

dragY = d3.drag()
    .on("start", function(d) {
        d3.select(this).attr("stroke", "black");
    })
    .on("drag", function(d) {
        y = d3.event.y;
        y = Math.max(-magnitude_max, y);
        y = Math.min(+magnitude_max, y);
        d.y = y;

        update();
    })
    .on("end", function(d) {
        d3.select(this).attr("stroke", null);
    })

//// Draw X axis line
function updateXaxis(root, n, dilatation) {
    if (root.select("#hline").empty()) {
        root.append("line")
            .attr("id", "hline")
            .attr("y1", 0)
            .attr("y2", 0)
            .attr("stroke", "gray")
            .attr("stroke-width", 2);
    }
    root.select("#hline")
        .transition()
        .duration(animate * duration)
        .attr("x1", 0)
        .attr("x2", n * pts_spacing * dilatation);
}

//// Update group top right corner positions
function updateCenteredLayout(root, n, line_y, dilatation) {
    const x = (width - n * pts_spacing * dilatation) / 2;
    root.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + x + "," + line_y + ")");
}

function updatePadLeft() {
    const right = (width - func_fn.length * pts_spacing) / 2;
    const left = right - padding * pts_spacing;
    pad_left.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + left + "," + func_line_y + ")");
}

function updatePadRight() {
    const left = (width + func_fn.length * pts_spacing) / 2;
    pad_right.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + left + "," + func_line_y + ")");
}

function updateConvLayout() {
    let x = (width - func_padded_fn.length * pts_spacing) / 2
    x += pts_spacing * step * stride
    x -= pts_spacing * (dilatation - 1) / 2;
    conv.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + x + "," + conv_line_y + ")");
}

function updateOutputLayout() {
    let x = (width - func_padded_fn.length * pts_spacing) / 2
    x += pts_spacing * ((kernel_fn.length - 1) * dilatation + 1) / 2
    x -= pts_spacing * stride / 2;
    out.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + x + "," + out_line_y + ")");
}

//// Drawing primitives
function drawPadding(root, n) {
    // data binding
    const cercles = root.selectAll("circle").data(d3.range(n));
    // remove elements no longer in data
    cercles.exit().transition().duration(animate * duration / 2).attr("r", 0).remove();
    // Create new entry for new elements in data
    const new_circles = cercles
        .enter()
        .append("circle")
        .attr("fill", "lightgray")
        .attr("r", 0)
        .transition()
        .duration(animate * duration * 2)
        .attr("r", radius)
    // Operates on both new and old elements
    cercles
        .merge(new_circles)
        .attr("cx", function(i) {
            return pts_spacing * (i + 0.5);
        })
        .attr("cy", 0);

    new_circles
;
}

function drawFunction(root, data, dilatation) {
    // data binding
    const vlines = root.selectAll("#vline").data(data);
    // remove elements no longer in data
    vlines.exit().transition().duration(animate * duration / 2).attr("stroke-width", 0).remove();
    // Create new entry for new elements in data
    const new_lines = vlines
        .enter()
        .append("line")
        .attr("id", "vline")
        .attr("stroke", "gray")
        .attr("stroke-width", 2)
        .attr("y1", 0);
    // Operates on both new and old elements
    vlines
        .merge(new_lines)
        .attr("y2", function(d, i) {
            return d.y;
        })
        .transition()
        .duration(animate * duration)
        .attr("x1", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("x2", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        });


    // data binding
    const cercles = root.selectAll("circle").data(data);
    // remove elements no longer in data
    cercles.exit().transition().duration(animate * duration / 2).attr("r", 0).remove();
    // Create new entry for new elements in data
    const new_circles = cercles
        .enter()
        .append("circle")
        .attr("fill", function(d, i) {
            return colors[i];
         })
        .attr("cx", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("r", 0)
        .call(dragY);
    // Operates on both new and old elements
    cercles
        .merge(new_circles)
        .attr("cy", function(d, i) {
            return d.y;
        })
        .transition()
        .duration(animate * duration)
        .attr("cx", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("r", radius);
}

function drawConvOps(root, data, dilatation) {
    // data binding
    const mult_lines = root.selectAll("#multline").data(data);
    // remove elements no longer in data
    mult_lines.exit().transition().duration(animate * duration / 2).attr("stroke-width", 0).remove();
    // Create new entry for new elements in data
    const new_mutl_lines = mult_lines
        .enter()
        .append("line")
        .attr("id", "multline")
        .attr("stroke", "steelblue")
        .attr("stroke-width", 0)
        .attr("y1", 0)
        .attr("y2", 0)
        .attr("x1", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("x2", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .transition("fade in")
        .duration(animate * duration / 2)
        .attr("stroke-width", 1.25)
        .attr("y2", -125);
    // Operates on both new and old elements
    mult_lines
        .transition()
        .duration(animate * duration)
        .attr("x1", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("x2", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })

    // data binding
    const add_lines = root.selectAll("#addline").data(data);
    // remove elements no longer in data
    add_lines.exit().transition().duration(animate * duration / 2).attr("stroke-width", 0).remove();
    // Create new entry for new elements in data
    const new_add_lines = add_lines
        .enter()
        .append("path")
        .attr("id", "addline")
        .attr("stroke", "darkorange")
        .attr("fill", "none");

    // Operates on both new and old elements
    add_lines
        .merge(new_add_lines)
        .transition()
        .duration(animate* duration)
        .attr("d", function(d, i) {
            const x_pts = pts_spacing * (i + 0.5) * dilatation;
            const x_middle = pts_spacing * data.length / 2 * dilatation;
            const points = [
                [x_pts, Math.max(d.y, -radius / 2) + 10],
                [x_pts, magnitude_max + 10],
                [x_pts, magnitude_max + 20],
                [x_middle, magnitude_max + 20],
                [x_middle, magnitude_max + 25],
                [x_middle, magnitude_max + 150 - magnitude_max],
            ];

            const line = d3
                .line()
                .x(d => d[0])
                .y(d => d[1])
                .curve(d3.curveBundle.beta(1));
            return line(points);
        });

    new_add_lines
        .attr("stroke-width", 0)
        .transition()
        .duration(animate * duration)
        .attr("stroke-width", 1.25);
}


function update() {
    func_padded_fn = padFunc(func_fn, padding);

    // kernel
    updateCenteredLayout(kernel, kernel_fn.length, kernel_line_y, dilatation);
    updateXaxis(kernel, kernel_fn.length, dilatation);
    drawFunction(kernel, kernel_fn, dilatation);

    // function
    updatePadLeft();
    updateXaxis(pad_left, padding, 1);
    drawPadding(pad_left, padding);

    updateCenteredLayout(func, func_fn.length, func_line_y, 1);
    updateXaxis(func, func_fn.length, 1);
    drawFunction(func, func_fn, 1);

    updatePadRight();
    updateXaxis(pad_right, padding, 1);
    drawPadding(pad_right, padding);

    // conv-ops
    updateConvLayout();
    updateXaxis(conv, kernel_fn.length, dilatation);
    drawFunction(conv, kernel_fn, dilatation);
    drawConvOps(ops, kernel_fn, dilatation);

    // result
    computeConv();
    updateOutputLayout();
    updateXaxis(out, out_fn.length, stride);
    drawFunction(out, out_fn, stride);

}
update();
animate = true;


function getConvRightPosition(step) {
    return step * stride + (kernel_fn.length - 1) * dilatation + 1;
}

//// User input
d3.select("#dilatation")
    .on("input", function() {
        dilatation = Math.min(Math.max(this.min, this.value), this.max);
        this.value = dilatation;
        while (getConvRightPosition(step) > func_padded_fn.length) {
            step -= 1;
        }
        update();
    })

d3.select("#stride")
    .on("input", function() {
        stride = Math.min(Math.max(this.min, this.value), this.max);
        this.value = stride;
        while (getConvRightPosition(step) > func_padded_fn.length) {
            step -= 1;
        }
        update();
    });

d3.select("#padding")
    .on("input", function() {
        padding = Math.min(Math.max(this.min, this.value), this.max);
        this.value = padding;
        while (getConvRightPosition(step) > func_fn.length + 2 *padding) {
            step -= 1;
        }
        update();
    });


d3.select("#prevstep")
    .on("click", function() {
        if (step > 0) {
            step -= 1;
            update();
        }
    });
d3.select("#nextstep")
    .on("click", function() {
        if (getConvRightPosition(step) + stride <= func_padded_fn.length) {
            step += 1;
            update();
        }
    });

d3.select("#new")
    .on("click", function() {
        if (kernel_fn.length < kernel_max_support) {
            kernel_fn.push({ y: 0 });
            while (getConvRightPosition(step) > func_padded_fn.length) {
                step -= 1;
            }
            update();
        }
    });
d3.select("#delete")
    .on("click", function() {
        if (kernel_fn.length > 1) {
            kernel_fn.pop({ y: 0 });
            update();
        }
    });
d3.select("#play")
    .on("click", function() {
        d3.selectAll("*").interrupt();
        svg.transition().on("end", function repeat(d){
            if (getConvRightPosition(step) + stride <= func_padded_fn.length) {
                step += 1;
                update();
                d3.active(this).transition().delay(1000).on("start", repeat);
            }
        })
    });
d3.select("#reset")
    .on("click", function() {
        d3.selectAll("*").interrupt();
        step = 0;
        update();
    });

  </script>
</body>
</html>
