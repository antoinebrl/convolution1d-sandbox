<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.8">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/x-mathjax-config">
  MathJax = {
    loader: {load: ['[tex]/color']},
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)'], ['\\[', '\\]']],
      packages: {'[+]': ['color']}
    },
    svg: {
      fontCache: 'global'
    }
  };

  </script>
  <script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/input/tex/extensions/colorV2.js" charset="UTF-8"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/input/tex/extensions/color.js" charset="UTF-8"></script>
  <style>
    body {
      font-family: monospace;
      font-size: 12px;
      color: #818181;
    }

    .row {
      display: flex;
    }
    .left {
      width: 34px;
    }
    .right {
      background-color: #f4f1de;
    }

    .btn-square {
      height: 1.5em !important;
      width: 1.5em  !important;
    }

    input[type=rande]{
      width: 80px;
    }
    input[type=number]{
      width: 32px;
    }

    #math {
      width: 100%;
      height: 90px;
      font-size: 1.2em;
    }
    .menu {
      margin-top: 120px;
    }

    .rotate270 {
        writing-mode: vertical-rl;
        transform: rotate(180deg);
        text-align: right;
    }
    .menu .btn {
      height:105px;
      z-index: 2; /* Stay on top */
    }
    .btn{
        display: inline-block;
        padding: 6px 5px;
        margin-bottom: 0;
        font-family: monospace;
        font-size: 12px;
        text-align: center;
        font-weight: 400;
        line-height: 1.42857143;
        white-space: nowrap;
        vertical-align: middle;
        -ms-touch-action: manipulation;
        touch-action: manipulation;
        cursor: pointer;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        background-image: none;
        border: 1px solid transparent;
        border-radius: 4px;
        text-decoration: none;
        margin-top: 4px;
        margin-bottom : 4px;

        color: #4e5462;
        background-color: #fff;
        border-color: #ccc;
    }
    .btn:hover {
      background-color: #eee;
      border-color: #aaa;
    }

    #result-btn {
        margin-top: 34px !important;
        cursor: default !important;
        border-bottom: 0px !important;
        border-top: 0px !important;
        border-right: 0px !important;
    }
    #result-btn:hover {
        border-bottom: 0px !important;
        border-top: 0px !important;
        border-right: 0px !important;
        background-color: #fff !important;
        border-color: #ccc !important ;
    }

    /* The side navigation menu */
   .sidenav {
       height: auto; /* 100% Full-height */
       width: 0; /* 0 width - change this with JavaScript */
       position: fixed; /* Stay in place */
       z-index: 1; /* Stay on top */
       background-color: #eee; /* Black*/
       overflow-x: hidden; /* Disable horizontal scroll */
       transition: 0.5s; /* 0.5 second transition effect to slide in the sidenav */
       margin-left: 28px;
       margin-top: 4px;
   }

   /* The navigation menu links */
   .sidenav a {
       color: #818181;
       display: block;
       transition: 0.3s;
   }

   /* When you mouse over the navigation links, change their color */
   .sidenav a:hover {
     color: #111;
   }

   /* Position and style the close button (top right corner) */
   .sidenav .closebtn {
       position: absolute;
       top: 0;
       right: 8px;
       font-size: 2em;
       margin-left: 20px;
   }

   /* Style page content - use this if you want to push the page content to the right when you open the side navigation */
   #main {
     transition: margin-left .5s;
     padding: 20px;
   }

   /* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */
   @media screen and (max-height: 450px) {
     .sidenav {padding-top: 15px;}
     .sidenav a {font-size: 18px;}
   }

   .nav-wrapper {
     padding-horizontal: 10px;
     margin: 10px;
     width: 200px;
   }

   .grabbing {
     cursor: move;
   }


  </style>
</head>
<body>
  <div class="row">
   <div class="left">
     <div class="menu">
       <div class="option">
         <div id="kernel-menu" class="sidenav">
           <div class="nav-wrapper">
             <div id="delete" class="btn btn-square">-</div>
             <div id="new" class="btn btn-square">+</div>
             <a href="javascript:void(0)" class="closebtn" onclick="closeNav('kernel-menu')">&times;</a>
             <p>dilatation:&nbsp;<input type="range" min="1" max="3" value="1" step="1" class="slider" id="dilatation"></p>
           </div>
         </div>
         <div class="btn rotate270" onclick="openNav('kernel-menu')">kernel</div>
       </div>
       <div class="option">
         <div id="signal-menu" class="sidenav">
           <div class="nav-wrapper">
             <a href="javascript:void(0)" class="closebtn" onclick="closeNav('signal-menu')">&times;</a>
             <p>padding:&nbsp;&nbsp;<input type="range" min="0" max="4" value="0" step="1" class="slider" id="padding"></p>
           </div>
         </div>
         <div class="btn rotate270" onclick="openNav('signal-menu')">signal</div>
       </div>
       <div class="option">
         <div id="convolution-menu" class="sidenav">
           <div class="nav-wrapper">
             <a href="javascript:void(0)" class="closebtn" onclick="closeNav('convolution-menu')">&times;</a>
             <p>stride:&nbsp;&nbsp;&nbsp;&nbsp;<input type="range" min="1" max="3" value="0" step="1" class="slider" id="stride"></p>
           </div>
         </div>
         <div class="btn rotate270" onclick="openNav('convolution-menu')">convolution</div>
       </div>
       <div class="option">
         <div class="btn rotate270" id="result-btn" onclick="openNav('result-menu')">result</div>
       </div>
     </div>

     <!-- Use any element to open the sidenav -->
     <!-- <svg width="200px" height=200px>
       <g transform="translate(0, 0)">
         <rect width="32px" height="32px" rx="4px" fill="steelblue" ></rect>
         <path d="M9 8 L9 24 L24 16 Z" fill=white></path>
       </g>
       <g transform="translate(50, 0)">
         <rect width="32px" height="32px" rx="4px" fill="steelblue" ></rect>
         <path d="M9 8 L9 24 L24 16 Z" fill=white></path>
         <line x1="23" y1="8" x2="23" y2="24" stroke="white" stroke-width="4"/>
       </g>
       <g transform="translate(32, 50) scale(-1,1)">
         <rect width="32px" height="32px" rx="4px" fill="steelblue" ></rect>
         <path d="M9 8 L9 24 L24 16 Z" fill=white></path>
         <line x1="23" y1="8" x2="23" y2="24" stroke="white" stroke-width="4"/>
       </g>
     </svg> -->
     <!-- <p>
       <input class="btn-square" type="button" id="new" value="+">
       <input class="btn-square" type="button" id="delete" value="-">
     </p>
     <p>dilation:
       <input type="number" id="dilatation" value=1 min="1" max="3">
     </p>
     <p>padding:
       <input type="number" id="padding" value=0 min="0" max="4">
     </p>
     <p>stride:
       <input type="number" id="stride" value=1 min="1" max="3">
     </p>
     <p>
       <input type="button" id="reset" value="&#171;">
       <input type="button" id="prevstep" value="&#706;">
       <input type="button" id="play" value="&#8227;">
       <input type="button" id="nextstep" value="&#707;">
     </p> -->
   </div>
   <div class="column right">
     <div id="math"></div>
     <div id="canvas"></div>
     <p>
       <div id="reset" class="btn btn-square">&#171;</div>
       <div id="prevstep" class="btn btn-square">&#706;</div>
       <div id="play" class="btn btn-square">&#8227;</div>
       <div id="nextstep" class="btn btn-square">&#707;</div>
     </p>
   </div>
  </div>



  <script>

  /* Set the width of the side navigation to 250px */
  function openNav(id) {
    let element = document.getElementById(id)
    console.log(element.style)
    if (element.style.width == "" || element.style.width == "0px") {
      element.style.width = "250px";
    } else {
      element.style.width = "0px";
    }
  }

  /* Set the width of the side navigation to 0 */
  function closeNav(id) {
    document.getElementById(id).style.width = "0";
  }




const width = 575;
const height = 625;

const bkg_color = "#f4f1de";
const text_color = "#818181";
const kernel_color = "#C72E38";
const func_color = "#1d3557";
const mult_color = "#d94a64";
const add_color = "#679436";
const out_color = "#8e576d";
const duration = 350;


const kernel_line_y = 80;
const func_line_y = 205;
const conv_line_y = 330;
const out_line_y = 490;

const magnitude_max = 50;
const pts_spacing = 25;
const kernel_max_support = 7;
const radius = 8;

let dilatation = 1;
let stride = 1;
let padding = 0;
let step = 0;
let animate = false;

const svg = d3.select("#canvas")
    .append("svg")
    // .style("background-color", "#f4f1de")
    .attr("width", width)
    .attr("height", height);

const kernel_fn = d3.range(5).map(i => ({ y: magnitude_max * (Math.random() * 2 - 1)}));
const func_fn = d3.range(15).map(i => ({ y: magnitude_max * (Math.random() * 2 - 1)}));
let func_padded_fn = [];
let out_fn = [];

const kernel = svg.append("g").attr("id", "kernel");
const conv = svg.append("g").attr("id", "conv");
const ops = conv.append("g").attr("id", "ops");
const pad_left = svg.append("g").attr("id", "pad_left");
const pad_right = svg.append("g").attr("id", "pad_right");
const func = svg.append("g").attr("id", "func");
const out = svg.append("g").attr("id", "out");


function padFunc(fn, pad) {
  let padded = [];
  for (let i = 0; i < pad; i++) {
    padded.push({y: 0});
  }
  padded = padded.concat(fn);
  for (let i = 0; i < pad; i++) {
    padded.push({y: 0});
  }
  return padded;
}

function computeConv(f, g) {
    out_fn = [];
    for (let s = 0; s <= step; s++) {
        let c = 0;
        for (let i = 0; i < g.length; i++) {
            c += g[i].y * f[s * stride + i * dilatation].y
        }
        out_fn.push({
            x: 0,
            y: - Math.sqrt(c / magnitude_max / magnitude_max / 2) * magnitude_max,
        });
    }
    return out_fn;
}

function updateEquation() {
    const equation = document.getElementById("math");
    // result
    latex_equation = "\\textcolor{" + out_color + "}{(f * g)}("+ step + ") "
    latex_equation += "= "
    // sum
    const p = Math.floor((kernel_fn.length - 1) / 2)
    if (kernel_fn.length > 1) {
        latex_equation += "\\textcolor{" + add_color + "}{"
        latex_equation += "\\sum_{k=-p}^{K-p}"
        latex_equation += "}"
    }

    // kernel
    latex_equation += "\\textcolor{" + kernel_color + "}{w_k}"
    // mult
    latex_equation += "\\textcolor{" + mult_color + "}{\\mathbf{\\times}} "

    // signal
    latex_equation += "\\textcolor{" + func_color + "}{"
    latex_equation += "f_{"
    latex_equation += " \\textcolor{" + text_color + "}{" + step + "} \\times \\textcolor{PaleVioletRed}{s}"
    latex_equation += "- \\textcolor{" + add_color + "}{k}"
    latex_equation += "*\\textcolor{darkorange}{d}"

    const offset = Math.floor(kernel_fn.length / 2) * dilatation - padding
    latex_equation += "+\\textcolor{CadetBlue}{o}"
    latex_equation += "}}"

    // put brackets around operators to reduce spacing
    legend = "\\small "
    legend += "\\textcolor{" + kernel_color + "}{K{=}" + kernel_fn.length +"}";
    legend += ",\\; \\textcolor{" + add_color + "}{p{=} \\lfloor (K - 1)/2 \\rfloor {=} " + p + "}"
    legend += ",\\; \\textcolor{darkorange}{d{=}" + dilatation + "}"
    legend += ",\\; \\textcolor{PaleVioletRed}{s{=}" + stride + "}"
    legend += ",\\; \\textcolor{CadetBlue}{o{=}\\lfloor K/2 \\rfloor {*} d {-} p {=}" + offset + "}"

    equation.innerHTML = "<p>" + "\\[" + latex_equation + "\\]" + "</p><p>" + "\\[" + legend + "\\]" + "</p>";
    try {
      MathJax.typeset(["#math"]);
    } catch (error) {
    }
}

dragY = d3.drag()
    .on("start", function(d) {
        d3.select(this).attr("stroke", "black");
        d3.select(this).style("cursor", null);
        d3.select("#canvas").node().classList.add("grabbing");;
    })
    .on("drag", function(d) {
        y = d3.event.y;
        y = Math.max(-magnitude_max, y);
        y = Math.min(+magnitude_max, y);
        d.y = y;

        update();
    })
    .on("end", function(d) {
        d3.select(this).attr("stroke", null);
        d3.select(this).style("cursor", "pointer");
        d3.select("#canvas").node().classList.remove("grabbing");;
    })

//// Draw X axis line
function updateXaxis(root, n, dilatation) {
    if (root.select("#hline").empty()) {
        root.append("line")
            .attr("id", "hline")
            .attr("y1", 0)
            .attr("y2", 0)
            .attr("stroke", "gray")
            .attr("stroke-width", 2);
    }
    root.select("#hline")
        .transition()
        .duration(animate * duration)
        .attr("x1", 0)
        .attr("x2", n * pts_spacing * dilatation);
}

//// Update group top right corner positions
function updateCenteredLayout(root, n, line_y, dilatation) {
    const x = (width - n * pts_spacing * dilatation) / 2;
    root.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + x + "," + line_y + ")");
}

function updatePadLeft() {
    const right = (width - func_fn.length * pts_spacing) / 2;
    const left = right - padding * pts_spacing;
    pad_left.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + left + "," + func_line_y + ")");
}

function updatePadRight() {
    const left = (width + func_fn.length * pts_spacing) / 2;
    pad_right.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + left + "," + func_line_y + ")");
}

function updateConvLayout() {
    let x = (width - func_padded_fn.length * pts_spacing) / 2;
    x += pts_spacing * step * stride;
    x -= pts_spacing * (dilatation - 1) / 2;
    conv.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + x + "," + conv_line_y + ")");
}

function updateOutputLayout() {
    let x = (width - func_padded_fn.length * pts_spacing) / 2;
    x += pts_spacing * ((Math.ceil(kernel_fn.length / 2) - 1) * dilatation);
    x -= pts_spacing * (stride - 1) / 2 ;
    out.transition()
        .duration(animate * duration)
        .attr("transform", "translate(" + x + "," + out_line_y + ")");
}

//// Drawing primitives
function drawPadding(root, n) {
    // data binding
    const cercles = root.selectAll("circle").data(d3.range(n));
    // remove elements no longer in data
    cercles.exit().transition().duration(animate * duration / 2).attr("r", 0).remove();
    // Create new entry for new elements in data
    const new_circles = cercles
        .enter()
        .append("circle")
        .attr("fill", "lightgray")
        .attr("r", 0)
        .transition()
        .duration(animate * duration * 2)
        .attr("r", radius)
    // Operates on both new and old elements
    cercles
        .merge(new_circles)
        .attr("cx", function(i) {
            return pts_spacing * (i + 0.5);
        })
        .attr("cy", 0);
}

function drawFunction(root, data, dilatation, color) {
    // data binding
    const vlines = root.selectAll("#vline").data(data);
    // remove elements no longer in data
    vlines.exit().transition().duration(animate * duration / 2).attr("stroke-width", 0).remove();
    // Create new entry for new elements in data
    const new_lines = vlines
        .enter()
        .append("line")
        .attr("id", "vline")
        .attr("stroke", "gray")
        .attr("stroke-width", 2)
        .attr("y1", 0)
        .attr("x1", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("x2", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        });
    // Operates on both new and old elements
    vlines
        .merge(new_lines)
        .attr("y2", function(d, i) {
            return d.y;
        })
        .transition()
        .duration(animate * duration)
        .attr("x1", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("x2", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        });


    // data binding
    const cercles = root.selectAll("circle").data(data);
    // remove elements no longer in data
    cercles.exit().transition().duration(animate * duration / 2).attr("r", 0).remove();
    // Create new entry for new elements in data
    const new_circles = cercles
        .enter()
        .append("circle")
        .attr("fill", color)
        .attr("cx", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("r", 0)
        .style("cursor", "pointer")
        .call(dragY)
        .on("dblclick", function(d) {
            d.y = d.y ? 0 : - magnitude_max;
            update()
        });
    // Operates on both new and old elements
    cercles
        .merge(new_circles)
        .attr("cy", function(d, i) {
            return d.y;
        })
        .transition()
        .duration(animate * duration)
        .attr("cx", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("r", radius);
}

function drawConvOps(root, data, dilatation) {
    // data binding
    const mult_lines = root.selectAll("#multline").data(data);
    // remove elements no longer in data
    mult_lines.exit().transition().duration(animate * duration / 2).attr("stroke-width", 0).remove();
    // Create new entry for new elements in data
    const new_mutl_lines = mult_lines
        .enter()
        .append("line")
        .attr("id", "multline")
        .attr("stroke", mult_color)
        .attr("stroke-width", 0)
        .attr("y1", 0)
        .attr("y2", 0)
        .attr("x1", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("x2", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .transition("fade in")
        .duration(animate * duration / 2)
        .attr("stroke-width", 1.25)
        .attr("y2", -125);
    // Operates on both new and old elements
    mult_lines
        .transition()
        .duration(animate * duration)
        .attr("x1", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })
        .attr("x2", function(d, i) {
            return pts_spacing * (i + 0.5) * dilatation;
        })

    // data binding
    const add_lines = root.selectAll("#addline").data(data);
    // remove elements no longer in data
    add_lines.exit().transition().duration(animate * duration / 2).attr("stroke-width", 0).remove();
    // Create new entry for new elements in data
    const new_add_lines = add_lines
        .enter()
        .append("path")
        .attr("id", "addline")
        .attr("stroke", add_color)
        .attr("fill", "none");

    // Operates on both new and old elements
    add_lines
        .merge(new_add_lines)
        .transition()
        .duration(animate* duration)
        .attr("d", function(d, i) {
            const x_pts = pts_spacing * (i + 0.5) * dilatation;
            const x_middle = pts_spacing * (Math.ceil(data.length / 2) - 0.5) * dilatation;
            const points = [
                [x_pts, Math.max(d.y, -radius / 2) + 10],
                [x_pts, magnitude_max + 10],
                [x_pts, magnitude_max + 20],
                [x_middle, magnitude_max + 20],
                [x_middle, magnitude_max + 25],
                [x_middle, magnitude_max + 150 - magnitude_max],
            ];

            const line = d3
                .line()
                .x(d => d[0])
                .y(d => d[1])
                .curve(d3.curveBundle.beta(1));
            return line(points);
        });

    new_add_lines
        .attr("stroke-width", 0)
        .transition()
        .duration(animate * duration)
        .attr("stroke-width", 1.25);
}


function update() {
    func_padded_fn = padFunc(func_fn, padding);
    updateEquation();

    // kernel
    console.log("kernel")
    updateCenteredLayout(kernel, kernel_fn.length, kernel_line_y, dilatation);
    updateXaxis(kernel, kernel_fn.length, dilatation);
    drawFunction(kernel, kernel_fn, dilatation, kernel_color);

    // function
    console.log("signal")
    updatePadLeft();
    updateXaxis(pad_left, padding, 1);
    drawPadding(pad_left, padding);

    updateCenteredLayout(func, func_fn.length, func_line_y, 1);
    updateXaxis(func, func_fn.length, 1);
    drawFunction(func, func_fn, 1, func_color);

    updatePadRight();
    updateXaxis(pad_right, padding, 1);
    drawPadding(pad_right, padding);

    // conv-ops
    console.log("conv")
    updateConvLayout();
    // reverse kernel in a non destructive way by making a copy
    const reversed_kernel_fn = [...kernel_fn].reverse();
    updateXaxis(conv, kernel_fn.length, dilatation);
    drawFunction(conv, reversed_kernel_fn, dilatation, kernel_color);
    drawConvOps(ops, reversed_kernel_fn, dilatation);

    // result
        console.log("result")
    out_fn = computeConv(func_padded_fn, reversed_kernel_fn);
    updateOutputLayout();
    updateXaxis(out, out_fn.length, stride);
    drawFunction(out, out_fn, stride, out_color);
    console.log("complited")

}
update();
animate = true;


function getConvRightPosition(step) {
    return step * stride + (kernel_fn.length - 1) * dilatation + 1;
}

//// User input
d3.select("#dilatation")
    .on("input", function() {
        dilatation = Math.min(Math.max(this.min, this.value), this.max);
        this.value = dilatation;
        while (step > 0 && getConvRightPosition(step) > func_padded_fn.length) {
            step -= 1;
        }
        update();
    })

d3.select("#stride")
    .on("input", function() {
        stride = Math.min(Math.max(this.min, this.value), this.max);
        this.value = stride;
        while (step > 0 && getConvRightPosition(step) > func_padded_fn.length) {
            step -= 1;
        }
        update();
    });

d3.select("#padding")
    .on("input", function() {
        padding = Math.min(Math.max(this.min, this.value), this.max);
        this.value = padding;
        while (step > 0 && getConvRightPosition(step) > func_fn.length + 2 *padding) {
            step -= 1;
        }
        update();
    });


d3.select("#prevstep")
    .on("click", function() {
        if (step > 0) {
            step -= 1;
            update();
        }
    });
d3.select("#nextstep")
    .on("click", function() {
        if (getConvRightPosition(step) + stride <= func_padded_fn.length) {
            step += 1;
            update();
        }
    });

d3.select("#new")
    .on("click", function() {
        if (kernel_fn.length < kernel_max_support) {
            kernel_fn.push({ y: 0 });
            while (step > 0 && getConvRightPosition(step) > func_padded_fn.length) {
                step -= 1;
            }
            update();
        }
    });
d3.select("#delete")
    .on("click", function() {
        if (kernel_fn.length > 1) {
            kernel_fn.pop({ y: 0 });
            update();
        }
    });
d3.select("#play")
    .on("click", function() {
        d3.selectAll("*").interrupt();
        svg.transition().on("end", function repeat(d){
            if (getConvRightPosition(step) + stride <= func_padded_fn.length) {
                step += 1;
                update();
                d3.active(this).transition().delay(1000).on("start", repeat);
            }
        })
    });
d3.select("#reset")
    .on("click", function() {
        d3.selectAll("*").interrupt();
        step = 0;
        update();
    });

  </script>
</body>
</html>
